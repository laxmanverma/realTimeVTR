<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Virtual Makeup</title>
    <!-- Add MediaPipe dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            padding: 20px 0;
            background-color: #fff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        h1 {
            color: #ff6b6b;
            margin: 0;
        }
        .app-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }
        .webcam-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
        }
        .video-wrapper {
            position: relative;
            width: 100%;
            margin-bottom: 20px;
        }
        #webcam {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 8px;
            background-color: #000;
        }
        #output_canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        .controls-container {
            flex: 1;
            min-width: 320px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
        }
        button {
            background-color: #ff6b6b;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #ff5252;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .feature-selector {
            margin: 20px 0;
        }
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            margin: 10px 0;
            gap: 10px;
        }
        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.2s;
        }
        .color-option:hover {
            transform: scale(1.2);
        }
        .color-option.selected {
            transform: scale(1.2);
            box-shadow: 0 0 0 2px white, 0 0 0 4px #ff6b6b;
        }
        .status-message {
            margin-top: 20px;
            padding: 10px;
            border-radius: 5px;
            background-color: #f8f9fa;
            display: none;
        }
        .status-message.error {
            background-color: #ffebee;
            color: #c62828;
            display: block;
        }
        .status-message.success {
            background-color: #e8f5e9;
            color: #2e7d32;
            display: block;
        }
        .hidden {
            display: none !important;
        }
        #downloadBtn {
            background-color: #43a047;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ff6b6b;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 2s linear infinite;
            margin: 10px auto;
            display: none;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .makeup-toggle {
            margin: 10px 0;
        }
        .opacity-control {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .opacity-slider {
            flex: 1;
            max-width: 150px;
        }
        .opacity-value {
            min-width: 40px;
            text-align: right;
        }
        .wing-control {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .wing-slider {
            flex: 1;
            max-width: 150px;
        }
        .wing-value {
            min-width: 40px;
            text-align: right;
        }
        .thickness-control {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .thickness-slider {
            flex: 1;
            max-width: 150px;
        }
        .thickness-value {
            min-width: 40px;
            text-align: right;
        }
    </style>
</head>
<body>
    <header>
        <h1>Real-Time Virtual Makeup</h1>
        <p>Try on virtual makeup in real-time!</p>
    </header>

    <div class="container">
        <div class="app-container">
            <div class="webcam-container">
                <div class="video-wrapper">
                    <video id="webcam" autoplay playsinline></video>
                    <canvas id="output_canvas"></canvas>
                </div>
                <div class="camera-controls">
                    <button id="startCameraBtn">Start Camera</button>
                    <button id="downloadBtn" disabled>Take Screenshot</button>
                </div>
                <div class="status-message" id="statusMessage"></div>
                <div class="loader" id="loader"></div>
            </div>

            <div class="controls-container">
                <h2>Makeup Options</h2>
                
                <!-- Eyelid and Eyeliner Toggles -->
                <div class="makeup-toggle">
                    <input type="checkbox" id="eyelinerToggle" checked>
                    <label for="eyelinerToggle">Eyeliner</label>
                    <div class="eyeliner-options" style="margin-left: 20px; margin-top: 5px;">
                        <div>
                            <input type="checkbox" id="upperEyelinerToggle" checked>
                            <label for="upperEyelinerToggle">Upper Eyeliner</label>
                            <div class="opacity-control">
                                <label for="upperEyelinerOpacity">Opacity:</label>
                                <input type="range" id="upperEyelinerOpacity" min="0" max="150" value="70" class="opacity-slider">
                                <span class="opacity-value">70%</span>
                            </div>
                            <div class="thickness-control">
                                <label for="eyelinerThickness">Thickness:</label>
                                <input type="range" id="eyelinerThickness" min="50" max="150" value="100" class="thickness-slider">
                                <span class="thickness-value">100%</span>
                            </div>
                            <div class="wing-control">
                                <label for="wingLength">Wing Length:</label>
                                <input type="range" id="wingLength" min="0" max="400" value="250" class="wing-slider">
                                <span class="wing-value">250%</span>
                            </div>
                        </div>
                        <div>
                            <input type="checkbox" id="kajalToggle" checked>
                            <label for="kajalToggle">Kajal (Lower Eyeliner)</label>
                            <div class="opacity-control">
                                <label for="kajalOpacity">Opacity:</label>
                                <input type="range" id="kajalOpacity" min="0" max="100" value="37" class="opacity-slider">
                                <span class="opacity-value">37%</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="makeup-toggle">
                    <input type="checkbox" id="cheeksToggle" checked>
                    <label for="cheeksToggle">Cheeks</label>
                    <div class="opacity-control">
                        <label for="cheeksOpacity">Opacity:</label>
                        <input type="range" id="cheeksOpacity" min="0" max="45" value="34" class="opacity-slider">
                        <span class="opacity-value">34%</span>
                    </div>
                </div>

                <!-- Color Palettes -->
                <div class="feature-selector">
                    <h3>Eyeliner Color</h3>
                    <div id="eyelinerColors" class="color-palette">
                        <div class="color-option selected" style="background-color: #000000;" data-color="black"></div>
                        <div class="color-option" style="background-color: #4B0082;" data-color="purple"></div>
                        <div class="color-option" style="background-color: #8B4513;" data-color="brown"></div>
                    </div>

                    <h3>Kajal Color</h3>
                    <div id="kajalColors" class="color-palette">
                        <div class="color-option selected" style="background-color: #000000;" data-color="black"></div>
                        <div class="color-option" style="background-color: #4B0082;" data-color="purple"></div>
                        <div class="color-option" style="background-color: #8B4513;" data-color="brown"></div>
                    </div>

                    <h3>Cheeks Color</h3>
                    <div id="cheeksColors" class="color-palette">
                        <div class="color-option selected" style="background-color: #FF7F7F;" data-color="pink"></div>
                        <div class="color-option" style="background-color: #FFAA7F;" data-color="peach"></div>
                        <div class="color-option" style="background-color: #CD7F32;" data-color="bronze"></div>
                        <div class="color-option" style="background-color: #000000;" data-color="black"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            // DOM Elements
            const video = document.getElementById('webcam');
            const outputCanvas = document.getElementById('output_canvas');
            const startCameraBtn = document.getElementById('startCameraBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const statusMessage = document.getElementById('statusMessage');
            const loader = document.getElementById('loader');
            
            // Canvas context
            const outputCtx = outputCanvas.getContext('2d');
            
            // Makeup state variables
            let currentColors = {
                eyeliner: 'black',  // Current selected color for eyeliner
                kajal: 'black',     // Current selected color for kajal
                cheeks: 'pink'      // Current selected color for cheeks
            };

            // Toggle states for each makeup feature
            let makeupToggles = {
                eyeliner: true,      // Master toggle for all eyeliner features
                upperEyeliner: true, // Toggle for upper eyeliner
                kajal: true,         // Toggle for kajal (lower eyeliner)
                cheeks: true         // Toggle for cheeks makeup
            };

            // Opacity settings for each makeup feature (0.0 to 1.0)
            let makeupOpacity = {
                upperEyeliner: 0.7,  // 70% opacity for upper eyeliner
                kajal: 0.37,         // 37% opacity for kajal
                cheeks: 0.34         // 34% opacity for cheeks
            };
            
            // Wing and thickness settings
            let wingLength = 2.5;    // Default wing length (250% of eye width)
            let wingOpacity = 0.5;   // Default wing opacity (50%)
            let eyelinerThickness = 1.0; // Default eyeliner thickness (100%)
            
            // Setup thickness control slider
            document.getElementById('eyelinerThickness').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                eyelinerThickness = value / 100; // Convert percentage to multiplier (0.5 to 1.5)
                e.target.nextElementSibling.textContent = `${value}%`;
            });

            // Setup wing length control slider
            document.getElementById('wingLength').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                wingLength = value / 100; // Convert percentage to multiplier (0 to 4.0)
                e.target.nextElementSibling.textContent = `${value}%`;
            });

            // Face detection and camera state
            let faceMesh = null;  // MediaPipe Face Mesh instance
            let camera = null;    // Camera instance for video capture
            
            /**
             * Main results handler for face detection and makeup application
             * Called for each frame when face is detected
             * @param {Object} results - Face detection results from MediaPipe
             */
            function onResults(results) {
                if (!results.multiFaceLandmarks || !results.image) {
                    return;
                }

                try {
                    // Set up canvas dimensions to match video
                    outputCanvas.width = video.videoWidth;
                    outputCanvas.height = video.videoHeight;
                    outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
                    outputCtx.drawImage(results.image, 0, 0, outputCanvas.width, outputCanvas.height);

                    if (results.multiFaceLandmarks.length > 0) {
                        const landmarks = results.multiFaceLandmarks[0];
                        
                        // Apply makeup features if enabled
                        if (makeupToggles.eyeliner) {
                            try {
                                applyEyelinerMakeup(landmarks, currentColors.eyeliner, currentColors.kajal);
                            } catch (error) {
                                console.error('Error applying eyeliner/kajal:', error);
                            }
                        }
                        if (makeupToggles.cheeks) {
                            try {
                                applyCheeksMakeup(landmarks, currentColors.cheeks);
                            } catch (error) {
                                console.error('Error applying cheeks:', error);
                            }
                        }
                        
                        downloadBtn.disabled = false;
                    }
                } catch (error) {
                    console.error('Error in onResults:', error);
                }
            }
            
            // Initialize MediaPipe Face Mesh
            async function initializeFaceMesh() {
                try {
                    showStatus('Loading face detection...', 'success');
                    loader.style.display = 'block';

                    faceMesh = new FaceMesh({
                        locateFile: (file) => {
                            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                        }
                    });

                    await faceMesh.initialize();

                    faceMesh.setOptions({
                        maxNumFaces: 1,
                        refineLandmarks: true,
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });

                    faceMesh.onResults(onResults);

                    showStatus('Face detection ready!', 'success');
                    return true;
                } catch (error) {
                    console.error('Error initializing face detection:', error);
                    showStatus('Error initializing face detection. Please try again.', 'error');
                    return false;
                } finally {
                    loader.style.display = 'none';
                }
            }
            
            // Start camera
            startCameraBtn.addEventListener('click', async () => {
                try {
                    showStatus('Starting camera...', 'success');
                    loader.style.display = 'block';

                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user'
                        }
                    });
                    
                    video.srcObject = stream;
                    await video.play();

                    // Set canvas sizes
                    outputCanvas.width = video.videoWidth;
                    outputCanvas.height = video.videoHeight;

                    await initializeFaceMesh();

                    camera = new Camera(video, {
                        onFrame: async () => {
                            if (faceMesh) {
                                await faceMesh.send({ image: video });
                            }
                        },
                        width: 640,
                        height: 480
                    });

                    await camera.start();
                    startCameraBtn.disabled = true;
                    showStatus('Camera ready!', 'success');
                    loader.style.display = 'none';
                    
                } catch (error) {
                    console.error('Error starting camera:', error);
                    showStatus(`Error starting camera: ${error.message}`, 'error');
                    loader.style.display = 'none';
                }
            });
            
            // Setup opacity controls
            document.querySelectorAll('.opacity-slider').forEach(slider => {
                const feature = slider.id.replace('Opacity', '');
                const valueDisplay = slider.nextElementSibling;
                
                slider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    makeupOpacity[feature] = value / 100;
                    valueDisplay.textContent = `${value}%`;
                });
            });
            
            /**
             * Applies eyeliner and kajal makeup to the detected face
             * @param {Array} landmarks - Face landmark points from MediaPipe
             * @param {string} eyelinerColor - Selected color for eyeliner
             * @param {string} kajalColor - Selected color for kajal
             */
            function applyEyelinerMakeup(landmarks, eyelinerColor, kajalColor) {
                if (!landmarks || !makeupToggles.upperEyeliner && !makeupToggles.kajal) return;

                try {
                    // Color definitions in RGB format
                    const colors = {
                        'black': [0, 0, 0],
                        'purple': [75, 0, 130],
                        'brown': [139, 69, 19]
                    };
                    const selectedEyelinerColor = colors[eyelinerColor] || colors.black;
                    const selectedKajalColor = colors[kajalColor] || colors.black;

                    // Define landmark points for eyeliner and kajal
                    // Points are ordered from inner to outer corner of the eye
                    const leftUpperEyeliner = [362, 398, 384, 385, 386, 387, 388, 466];  // Left eye upper eyeliner points
                    const rightUpperEyeliner = [133, 173, 157, 158, 159, 160, 161, 246]; // Right eye upper eyeliner points
                    const leftKajal = [263, 249, 390, 373, 374, 380, 381, 382];          // Left eye kajal points
                    const rightKajal = [33, 7, 163, 144, 145, 153, 154, 155];            // Right eye kajal points

                    outputCtx.save();

                    /**
                     * Draws upper eyeliner with wing
                     * @param {Array} points - Landmark points for the eyeliner
                     * @param {Array} color - RGB color values
                     * @param {boolean} isLeftEye - Whether this is the left eye
                     */
                    function drawUpperEyeliner(points, color, isLeftEye) {
                        if (!points || points.length === 0) return;

                        // Calculate base width with thickness multiplier
                        const baseWidth = outputCanvas.width * 0.00168 * eyelinerThickness;
                        const opacity = makeupOpacity.upperEyeliner;

                        // Create temporary canvas for better blending
                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCanvas.width = outputCanvas.width;
                        tempCanvas.height = outputCanvas.height;

                        /**
                         * Creates a smooth path for the eyeliner using bezier curves
                         * @param {Array} points - Landmark points
                         * @param {Array} landmarks - All face landmarks
                         * @param {boolean} isInnerLine - Whether this is the inner line
                         * @returns {Path2D} Smooth path for the eyeliner
                         */
                        function createSmoothEyelinerPath(points, landmarks, isInnerLine = false) {
                            const path = new Path2D();
                            const halfPoints = points.slice(0, points.length);
                            
                            // Convert points to canvas coordinates
                            const eyelinerPoints = halfPoints.map(idx => {
                                const pt = landmarks[idx];
                                return { x: pt.x * outputCanvas.width, y: pt.y * outputCanvas.height };
                            });

                            // Add control points for smoother curve
                            const controlPoints = [];
                            for (let i = 0; i < eyelinerPoints.length - 1; i++) {
                                const current = eyelinerPoints[i];
                                const next = eyelinerPoints[i + 1];
                                
                                // Calculate mid-point
                                const midX = (current.x + next.x) / 2;
                                const midY = (current.y + next.y) / 2;
                                
                                // Add control points with slight offset for natural curve
                                const position = i / (eyelinerPoints.length - 1);
                                const curveOffset = isInnerLine ? 
                                    (position < 0.25 ? -baseWidth * 0.4 :
                                     position < 0.5 ? -baseWidth * 0.6 :
                                     position < 0.75 ? -baseWidth * 0.7 :
                                     -baseWidth * 0.6) :
                                    (position < 0.25 ? -baseWidth * 0.8 :
                                     position < 0.5 ? -baseWidth * 1.4 :
                                     position < 0.75 ? -baseWidth * 1.8 :
                                     -baseWidth * 1.6);

                                controlPoints.push({
                                    x: midX,
                                    y: midY + curveOffset,
                                    tension: 0.5
                                });
                            }

                            // Draw smooth path using control points
                            path.moveTo(eyelinerPoints[0].x, eyelinerPoints[0].y + (isInnerLine ? -baseWidth * 0.4 : -baseWidth * 0.8));
                            
                            for (let i = 0; i < controlPoints.length; i++) {
                                const current = eyelinerPoints[i];
                                const next = eyelinerPoints[i + 1];
                                const control = controlPoints[i];
                                
                                // Calculate control points for bezier curve
                                const cp1x = current.x + (control.x - current.x) * control.tension;
                                const cp1y = current.y + (control.y - current.y) * control.tension;
                                const cp2x = next.x + (control.x - next.x) * control.tension;
                                const cp2y = next.y + (control.y - next.y) * control.tension;
                                
                                path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.x, next.y + (isInnerLine ? -baseWidth * 0.4 : -baseWidth * 0.8));
                            }

                            return path;
                        }

                        // Draw main eyeliner with smooth path and gradient
                        const mainPath = createSmoothEyelinerPath(points, landmarks);
                        tempCtx.save();
                        
                        // Create gradient for main eyeliner with varying opacity
                        const eyelinerGradient = tempCtx.createLinearGradient(
                            0, landmarks[points[0]].y * outputCanvas.height,
                            0, landmarks[points[points.length-1]].y * outputCanvas.height
                        );
                        // Add gradient stops for natural fade effect
                        eyelinerGradient.addColorStop(0, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.5})`);
                        eyelinerGradient.addColorStop(0.2, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.8})`);
                        eyelinerGradient.addColorStop(0.5, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.95})`);
                        eyelinerGradient.addColorStop(0.8, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.95})`);
                        eyelinerGradient.addColorStop(1, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.7})`);

                        // Draw main eyeliner with varying thickness
                        tempCtx.strokeStyle = eyelinerGradient;
                        tempCtx.lineWidth = baseWidth * 3.5;
                        tempCtx.lineCap = 'round';
                        tempCtx.lineJoin = 'round';
                        tempCtx.stroke(mainPath);

                        // Draw inner line for depth effect
                        const innerPath = createSmoothEyelinerPath(points, landmarks, true);
                        
                        // Create gradient for inner line
                        const innerGradient = tempCtx.createLinearGradient(
                            0, landmarks[points[0]].y * outputCanvas.height,
                            0, landmarks[points[points.length-1]].y * outputCanvas.height
                        );
                        // Add gradient stops for inner line
                        innerGradient.addColorStop(0, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.2})`);
                        innerGradient.addColorStop(0.3, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.4})`);
                        innerGradient.addColorStop(0.6, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.5})`);
                        innerGradient.addColorStop(1, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.3})`);

                        // Draw inner line
                        tempCtx.strokeStyle = innerGradient;
                        tempCtx.lineWidth = baseWidth * 1.4;
                        tempCtx.stroke(innerPath);
                        tempCtx.restore();

                        // Apply blur for softer look
                        tempCtx.filter = 'blur(0.7px)';
                        tempCtx.globalCompositeOperation = 'source-over';
                        outputCtx.drawImage(tempCanvas, 0, 0);
                        tempCtx.filter = 'none';

                        // Calculate wing points and draw wing if enabled
                        if (wingLength > 0) {
                            // Calculate wing direction and length
                            const dx = landmarks[points[points.length-1]].x * outputCanvas.width - landmarks[points[points.length-2]].x * outputCanvas.width;
                            const dy = landmarks[points[points.length-1]].y * outputCanvas.height - landmarks[points[points.length-2]].y * outputCanvas.height;
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate wing points
                            const eyeWidth = Math.sqrt(dx * dx + dy * dy);
                            const startOffset = eyeWidth * 0.15;
                            const wingStartX = landmarks[points[points.length-1]].x * outputCanvas.width + Math.cos(angle) * startOffset;
                            const wingStartY = landmarks[points[points.length-1]].y * outputCanvas.height + Math.sin(angle) * startOffset;
                            const wingAngle = isLeftEye ? angle - Math.PI * 0.15 : angle + Math.PI * 0.15;
                            const wingSize = eyeWidth * wingLength * 1.2;
                            const wingEndX = wingStartX + Math.cos(wingAngle) * wingSize;
                            const wingEndY = wingStartY + Math.sin(wingAngle) * wingSize;

                            // Draw wing directly on output canvas
                            outputCtx.save();
                            
                            // Calculate triangle points
                            const baseThickness = baseWidth * 4.8;
                            const perpAngle = wingAngle + Math.PI / 2;
                            const baseOffsetX = Math.cos(perpAngle) * (baseThickness / 2);
                            const baseOffsetY = Math.sin(perpAngle) * (baseThickness / 2);
                            const baseLeftX = wingStartX - baseOffsetX;
                            const baseLeftY = wingStartY - baseOffsetY;
                            const baseRightX = wingStartX + baseOffsetX;
                            const baseRightY = wingStartY + baseOffsetY;

                            // Draw filled triangle with higher opacity
                            outputCtx.beginPath();
                            outputCtx.moveTo(baseLeftX, baseLeftY);
                            outputCtx.lineTo(baseRightX, baseRightY);
                            outputCtx.lineTo(wingEndX, wingEndY);
                            outputCtx.closePath();
                            
                            const wingGradient = outputCtx.createLinearGradient(
                                wingStartX, wingStartY,
                                wingEndX, wingEndY
                            );
                            wingGradient.addColorStop(0, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${wingOpacity * 1.5})`);
                            wingGradient.addColorStop(0.2, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${wingOpacity * 1.3})`);
                            wingGradient.addColorStop(0.7, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${wingOpacity * 1.2})`);
                            wingGradient.addColorStop(0.9, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${wingOpacity * 1.1})`);
                            wingGradient.addColorStop(1, `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0)`);
                            
                            outputCtx.fillStyle = wingGradient;
                            outputCtx.fill();

                            // Draw wing outline
                            outputCtx.beginPath();
                            outputCtx.moveTo(baseLeftX, baseLeftY);
                            outputCtx.lineTo(baseRightX, baseRightY);
                            outputCtx.lineTo(wingEndX, wingEndY);
                            outputCtx.closePath();
                            outputCtx.strokeStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${wingOpacity * 1.2})`;
                            outputCtx.lineWidth = baseWidth * 0.8;
                            outputCtx.stroke();
                            
                            outputCtx.restore();
                        }
                    }

                    /**
                     * Draws kajal (lower eyeliner) with smooth path and texture
                     * @param {Array} points - Landmark points for the kajal
                     * @param {Array} color - RGB color values
                     */
                    function drawKajal(points, color) {
                        if (!points || points.length === 0) return;

                        const width = outputCanvas.width * 0.0018;
                        const opacity = makeupOpacity.kajal;

                        // Create texture for kajal
                        function createKajalTexture(width, height) {
                            const textureCanvas = document.createElement('canvas');
                            const textureCtx = textureCanvas.getContext('2d');
                            textureCanvas.width = width;
                            textureCanvas.height = height;
                            
                            // Create pencil-like texture
                            const imageData = textureCtx.createImageData(width, height);
                            const data = imageData.data;
                            
                            for (let i = 0; i < data.length; i += 4) {
                                // Make grain much more subtle for smoothness
                                const noise = Math.random();
                                const grain = noise < 0.3 ? Math.random() * 0.05 : // Much lighter spots
                                            noise < 0.7 ? Math.random() * 0.02 : // Even lighter
                                            Math.random() * 0.01;                // Barely visible
                                
                                // Reduce directional variation
                                const y = Math.floor((i / 4) / width);
                                const x = (i / 4) % width;
                                const directionFactor = Math.sin(x * 0.1) * 0.01;
                                
                                const finalGrain = grain + directionFactor;
                                
                                data[i] = finalGrain * 255;     // R
                                data[i + 1] = finalGrain * 255; // G
                                data[i + 2] = finalGrain * 255; // B
                                data[i + 3] = finalGrain * 255; // A
                            }
                            
                            textureCtx.putImageData(imageData, 0, 0);
                            return textureCanvas;
                        }

                        // Create a temporary canvas for better blending
                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCanvas.width = outputCanvas.width;
                        tempCanvas.height = outputCanvas.height;

                        // Draw main line with varying thickness and texture
                        tempCtx.beginPath();
                        let firstPoint = true;
                        const halfPoints = points.slice(0, points.length);

                        // Helper: Catmull-Rom spline interpolation
                        function catmullRomSpline(pts, numSegments) {
                            const result = [];
                            for (let i = 0; i < pts.length - 1; i++) {
                                const p0 = pts[i === 0 ? i : i - 1];
                                const p1 = pts[i];
                                const p2 = pts[i + 1];
                                const p3 = pts[i + 2 < pts.length ? i + 2 : i + 1];
                                for (let t = 0; t < numSegments; t++) {
                                    const tt = t / numSegments;
                                    const tt2 = tt * tt;
                                    const tt3 = tt2 * tt;
                                    const x = 0.5 * ((2 * p1.x) +
                                        (-p0.x + p2.x) * tt +
                                        (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * tt2 +
                                        (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * tt3);
                                    const y = 0.5 * ((2 * p1.y) +
                                        (-p0.y + p2.y) * tt +
                                        (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * tt2 +
                                        (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * tt3);
                                    result.push({ x, y });
                                }
                            }
                            // Add last point
                            result.push(pts[pts.length - 1]);
                            return result;
                        }

                        // Gather kajal points in canvas coordinates
                        const kajalPts = halfPoints.map(idx => {
                            const pt = landmarks[idx];
                            return { x: pt.x * outputCanvas.width, y: pt.y * outputCanvas.height };
                        });
                        // Interpolate for smoothness
                        const smoothPts = catmullRomSpline(kajalPts, 12); // 12 segments between each pair

                        // Draw the smooth kajal path
                        tempCtx.moveTo(smoothPts[0].x, smoothPts[0].y);
                        for (let i = 1; i < smoothPts.length; i++) {
                            tempCtx.lineTo(smoothPts[i].x, smoothPts[i].y);
                        }
                        tempCtx.lineCap = 'round';
                        tempCtx.lineJoin = 'round';

                        try {
                            const startPoint = landmarks[halfPoints[0]];
                            const endPoint = landmarks[halfPoints[halfPoints.length-1]];
                            if (!startPoint || !endPoint) return;

                            // Create gradient with natural variation
                            const gradient = tempCtx.createLinearGradient(
                                0, startPoint.y * outputCanvas.height,
                                0, endPoint.y * outputCanvas.height
                            );
                            
                            // More natural gradient stops for kajal
                            gradient.addColorStop(0, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.7})`);
                            gradient.addColorStop(0.2, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.95})`);
                            gradient.addColorStop(0.4, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.9})`);
                            gradient.addColorStop(0.6, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.95})`);
                            gradient.addColorStop(0.8, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.85})`);
                            gradient.addColorStop(1, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.7})`);

                            tempCtx.strokeStyle = gradient;
                            tempCtx.lineWidth = width * 3.5;
                            tempCtx.lineCap = 'round';
                            tempCtx.lineJoin = 'round';
                            tempCtx.stroke();

                            // Add much more subtle texture layer
                            const texture = createKajalTexture(tempCanvas.width, tempCanvas.height);
                            tempCtx.globalCompositeOperation = 'overlay';
                            tempCtx.globalAlpha = 0.08; // Much lower texture opacity
                            tempCtx.drawImage(texture, 0, 0);
                            tempCtx.globalAlpha = 1.0;
                            tempCtx.globalCompositeOperation = 'source-over';

                            // Add inner line with no random variation
                            tempCtx.beginPath();
                            firstPoint = true;

                            for (let i = 0; i < halfPoints.length; i++) {
                                const point = landmarks[halfPoints[i]];
                                if (!point) continue;
                                
                                const x = point.x * outputCanvas.width;
                                const y = point.y * outputCanvas.height;
                                const position = i / halfPoints.length;
                                
                                // Vary inner curve for natural look
                                const innerCurve = position < 0.3 ? width * 0.5 : 
                                                 position < 0.7 ? width * 0.8 : 
                                                 width * 0.5;
                                // const variation = Math.cos(position * Math.PI * 2) * width * 0.2;

                                if (firstPoint) {
                                    tempCtx.moveTo(x, y + innerCurve);
                                    firstPoint = false;
                                } else {
                                    const prevPoint = landmarks[halfPoints[i-1]];
                                    if (!prevPoint) continue;
                                    
                                    const prevX = prevPoint.x * outputCanvas.width;
                                    const prevY = prevPoint.y * outputCanvas.height;
                                    
                                    const cp1x = prevX + (x - prevX) * 0.4;
                                    const cp1y = prevY + innerCurve * 0.8;
                                    const cp2x = x - (x - prevX) * 0.4;
                                    const cp2y = y + innerCurve * 0.8;
                                    
                                    tempCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y + innerCurve);
                                }
                            }

                            // Inner line gradient with texture
                            const innerGradient = tempCtx.createLinearGradient(
                                0, startPoint.y * outputCanvas.height,
                                0, endPoint.y * outputCanvas.height
                            );
                            innerGradient.addColorStop(0, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.4})`);
                            innerGradient.addColorStop(0.3, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.6})`);
                            innerGradient.addColorStop(0.7, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.6})`);
                            innerGradient.addColorStop(1, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.4})`);

                            tempCtx.strokeStyle = innerGradient;
                            tempCtx.lineWidth = width * 1.6;
                            tempCtx.stroke();

                            // Apply more blur for a softer, smoother look
                            tempCtx.filter = 'blur(1.2px)';
                            outputCtx.drawImage(tempCanvas, 0, 0);
                            
                            // Add a second layer with different texture
                            tempCtx.filter = 'blur(0.7px)';
                            tempCtx.globalAlpha = 0.18;
                            outputCtx.drawImage(tempCanvas, 0, 0);
                            
                            // Final very subtle blur for seamless blending
                            tempCtx.filter = 'blur(0.4px)';
                            tempCtx.globalAlpha = 0.12;
                            outputCtx.drawImage(tempCanvas, 0, 0);
                            
                            tempCtx.filter = 'none';
                            tempCtx.globalAlpha = 1.0;
                            
                        } catch (error) {
                            console.error('Error drawing kajal:', error);
                        }
                    }

                    // Apply makeup based on toggle states
                    if (makeupToggles.upperEyeliner) {
                        drawUpperEyeliner(leftUpperEyeliner, selectedEyelinerColor, true);
                        drawUpperEyeliner(rightUpperEyeliner, selectedEyelinerColor, false);
                    }

                    if (makeupToggles.kajal) {
                        drawKajal(leftKajal, selectedKajalColor);
                        drawKajal(rightKajal, selectedKajalColor);
                    }

                    outputCtx.restore();
                } catch (error) {
                    console.error('Error in applyEyelinerMakeup:', error);
                }
            }
            
            // Apply blush
            function applyCheeksMakeup(landmarks, color) {
                if (!landmarks) return;

                try {
                    // Define landmark points for cheeks following zygomatic arch
                    const leftCheekPoints = [
                        123,  // Upper cheek point
                        50,   // Outer cheek point
                        36,   // Temple point
                        206,  // Mid cheek point
                        187,  // Lower cheek point
                        147   // Inner cheek point
                    ];
                    const rightCheekPoints = [
                        352,  // Upper cheek point
                        280,  // Outer cheek point
                        266,  // Temple point
                        426,  // Mid cheek point
                        407,  // Lower cheek point
                        376   // Inner cheek point
                    ];
                    
                    /**
                     * Calculates the center point for cheek makeup with responsive positioning
                     * @param {Array} points - Landmark points for the cheek
                     * @returns {Object|null} Center point coordinates or null if invalid
                     */
                    function calculateCenter(points) {
                        if (!points || points.length === 0) return null;
                        
                        // Calculate weighted center based on zygomatic arch shape
                        const weights = [0.3, 0.2, 0.1, 0.2, 0.1, 0.1]; // Weights for each point
                        const center = { x: 0, y: 0 };
                        let totalWeight = 0;
                        
                        points.forEach((index, i) => {
                            const point = landmarks[index];
                            if (point) {
                                center.x += point.x * weights[i];
                                center.y += point.y * weights[i];
                                totalWeight += weights[i];
                            }
                        });
                        
                        if (totalWeight === 0) return null;
                        
                        center.x /= totalWeight;
                        center.y /= totalWeight;
                        
                        // Calculate responsive vertical offset based on viewport width
                        const viewportWidth = window.innerWidth;
                        let verticalOffset;
                        if (viewportWidth <= 480) { // Mobile view
                            verticalOffset = 0.015; // Smaller offset for mobile
                        } else if (viewportWidth <= 768) { // Tablet view
                            verticalOffset = 0.018;
                        } else { // Desktop view
                            verticalOffset = 0.02;
                        }
                        
                        // Apply the responsive offset
                        center.y -= verticalOffset;
                        return center;
                    }
                    
                    // Calculate center points for both cheeks
                    const leftCheekCenter = calculateCenter(leftCheekPoints);
                    const rightCheekCenter = calculateCenter(rightCheekPoints);
                    
                    if (!leftCheekCenter || !rightCheekCenter) return;
                    
                    // Color definitions in RGB format
                    const colors = {
                        'pink': [255, 127, 180],
                        'peach': [255, 186, 169],
                        'bronze': [181, 133, 71],
                        'black': [0, 0, 0]
                    };
                    const selectedColor = colors[color] || colors.pink;
                    
                    // Adjust opacity based on color
                    const baseOpacity = color === 'black' ? 
                        makeupOpacity.cheeks * 0.5 : // Reduce opacity for black color
                        makeupOpacity.cheeks;        // Use full opacity for other colors
                    
                    outputCtx.save();
                    
                    // Apply makeup to both cheeks
                    ['left', 'right'].forEach(side => {
                        const center = side === 'left' ? leftCheekCenter : rightCheekCenter;
                        const x = center.x * outputCanvas.width;
                        const y = center.y * outputCanvas.height;
                        
                        try {
                            const tempCanvas = document.createElement('canvas');
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCanvas.width = outputCanvas.width;
                            tempCanvas.height = outputCanvas.height;
                            
                            // Adjust oval dimensions based on viewport
                            const viewportWidth = window.innerWidth;
                            let radiusX, radiusY;
                            if (viewportWidth <= 480) { // Mobile view
                                radiusX = outputCanvas.width * 0.045;  // Slightly wider for mobile
                                radiusY = outputCanvas.width * 0.065;  // Slightly taller for mobile
                            } else if (viewportWidth <= 768) { // Tablet view
                                radiusX = outputCanvas.width * 0.042;
                                radiusY = outputCanvas.width * 0.062;
                            } else { // Desktop view
                                radiusX = outputCanvas.width * 0.04;
                                radiusY = outputCanvas.width * 0.06;
                            }
                            
                            // Create base gradient with softer edges
                            const gradient = tempCtx.createRadialGradient(
                                x, y, radiusX * 0.05,  // Even smaller inner circle
                                x, y, radiusX * 2.2    // Larger outer circle for softer fade
                            );
                            
                            // More gradual color stops for softer edges
                            gradient.addColorStop(0, `rgba(${selectedColor[0]}, ${selectedColor[1]}, ${selectedColor[2]}, ${baseOpacity * 0.6})`);
                            gradient.addColorStop(0.15, `rgba(${selectedColor[0]}, ${selectedColor[1]}, ${selectedColor[2]}, ${baseOpacity * 0.7})`);
                            gradient.addColorStop(0.3, `rgba(${selectedColor[0]}, ${selectedColor[1]}, ${selectedColor[2]}, ${baseOpacity * 0.5})`);
                            gradient.addColorStop(0.5, `rgba(${selectedColor[0]}, ${selectedColor[1]}, ${selectedColor[2]}, ${baseOpacity * 0.25})`);
                            gradient.addColorStop(0.7, `rgba(${selectedColor[0]}, ${selectedColor[1]}, ${selectedColor[2]}, ${baseOpacity * 0.1})`);
                            gradient.addColorStop(0.9, `rgba(${selectedColor[0]}, ${selectedColor[1]}, ${selectedColor[2]}, ${baseOpacity * 0.05})`);
                            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                            
                            tempCtx.fillStyle = gradient;
                            tempCtx.beginPath();
                            
                            // Draw elongated oval with softer edges
                            tempCtx.save();
                            tempCtx.translate(x, y);
                            const rotation = side === 'left' ? -Math.PI * 0.15 : Math.PI * 0.15;
                            tempCtx.rotate(rotation);
                            tempCtx.scale(1, radiusY / radiusX);
                            tempCtx.arc(0, 0, radiusX, 0, Math.PI * 2);
                            tempCtx.restore();
                            
                            tempCtx.fill();

                            // Create and apply noise texture
                            const noiseTexture = createNoiseTexture(tempCanvas.width, tempCanvas.height);
                            tempCtx.globalCompositeOperation = 'overlay';
                            tempCtx.globalAlpha = 0.15; // Subtle texture
                            tempCtx.drawImage(noiseTexture, 0, 0);
                            tempCtx.globalAlpha = 1.0;
                            tempCtx.globalCompositeOperation = 'source-over';

                            // Enhanced mask gradient for even softer edges
                            const maskGradient = tempCtx.createLinearGradient(
                                x, y - radiusY * 1.4,
                                x, y + radiusY * 1.0
                            );
                            maskGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                            maskGradient.addColorStop(0.1, 'rgba(0, 0, 0, 0.05)');
                            maskGradient.addColorStop(0.3, 'rgba(0, 0, 0, 0.15)');
                            maskGradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.2)');
                            maskGradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.15)');
                            maskGradient.addColorStop(0.9, 'rgba(0, 0, 0, 0.05)');
                            maskGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                            // Apply the mask
                            tempCtx.globalCompositeOperation = 'destination-in';
                            tempCtx.fillStyle = maskGradient;
                            tempCtx.fillRect(x - radiusX * 2.5, y - radiusY * 2.5, radiusX * 5, radiusY * 5);
                            tempCtx.globalCompositeOperation = 'source-over';

                            // Enhanced blur for more natural blending
                            const blurAmount = color === 'black' ? '14px 18px' : '12px 16px';
                            tempCtx.filter = `blur(${blurAmount})`;
                            outputCtx.drawImage(tempCanvas, 0, 0);
                            tempCtx.filter = 'none';
                            
                            // Additional soft blur layers for extra edge softening
                            tempCtx.filter = 'blur(10px)';
                            tempCtx.globalAlpha = 0.25;
                            outputCtx.drawImage(tempCanvas, 0, 0);
                            
                            // Final very soft blur for seamless blending
                            tempCtx.filter = 'blur(6px)';
                            tempCtx.globalAlpha = 0.15;
                            outputCtx.drawImage(tempCanvas, 0, 0);
                            
                            tempCtx.filter = 'none';
                            tempCtx.globalAlpha = 1.0;
                            
                        } catch (error) {
                            console.error('Error applying cheek makeup:', error);
                        }
                    });
                    
                    outputCtx.restore();
                } catch (error) {
                    console.error('Error in applyCheeksMakeup:', error);
                }
            }
            
            // Download screenshot
            downloadBtn.addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = `virtual-makeup-${Date.now()}.png`;
                link.href = outputCanvas.toDataURL('image/png');
                link.click();
            });
            
            // Show status message
            function showStatus(message, type) {
                statusMessage.textContent = message;
                statusMessage.className = 'status-message';
                if (type) {
                    statusMessage.classList.add(type);
                }
                
                if (type === 'success') {
                    setTimeout(() => {
                        statusMessage.classList.remove('success');
                    }, 5000);
                }
            }
            
            // Setup makeup toggles
            document.querySelectorAll('input[type="checkbox"]').forEach(toggle => {
                toggle.addEventListener('change', (e) => {
                    const feature = e.target.id.replace('Toggle', '');
                    if (feature === 'eyeliner') {
                        // When main toggle is turned off, turn off both specific toggles
                        if (!e.target.checked) {
                            makeupToggles.upperEyeliner = false;
                            makeupToggles.kajal = false;
                            document.getElementById('upperEyelinerToggle').checked = false;
                            document.getElementById('kajalToggle').checked = false;
                        }
                    } else if (feature === 'upperEyeliner' || feature === 'kajal') {
                        // Update the specific toggle
                        makeupToggles[feature] = e.target.checked;
                        
                        // If both specific toggles are off, turn off the main toggle
                        if (!makeupToggles.upperEyeliner && !makeupToggles.kajal) {
                            makeupToggles.eyeliner = false;
                            document.getElementById('eyelinerToggle').checked = false;
                        } else {
                            // If either specific toggle is on, turn on the main toggle
                            makeupToggles.eyeliner = true;
                            document.getElementById('eyelinerToggle').checked = true;
                        }
                    } else {
                        makeupToggles[feature.toLowerCase()] = e.target.checked;
                    }
                });
            });
            
            // Setup color selection
            document.querySelectorAll('.color-option').forEach(colorOption => {
                colorOption.addEventListener('click', () => {
                    const paletteId = colorOption.parentElement.id;
                    const feature = paletteId.replace('Colors', '');
                    
                    currentColors[feature] = colorOption.dataset.color;
                    
                    document.querySelectorAll(`#${paletteId} .color-option`).forEach(option => {
                        option.classList.remove('selected');
                    });
                    colorOption.classList.add('selected');
                });
            });
        });
    </script>
</body>
</html> 