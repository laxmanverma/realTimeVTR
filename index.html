<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Virtual Makeup</title>
    <!-- Add MediaPipe dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            padding: 20px 0;
            background-color: #fff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        h1 {
            color: #ff6b6b;
            margin: 0;
        }
        .app-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }
        .webcam-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
        }
        .video-wrapper {
            position: relative;
            width: 100%;
            margin-bottom: 20px;
        }
        #webcam {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 8px;
            background-color: #000;
        }
        #output_canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        .controls-container {
            flex: 1;
            min-width: 320px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
        }
        button {
            background-color: #ff6b6b;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #ff5252;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .feature-selector {
            margin: 20px 0;
        }
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            margin: 10px 0;
            gap: 10px;
        }
        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.2s;
        }
        .color-option:hover {
            transform: scale(1.2);
        }
        .color-option.selected {
            transform: scale(1.2);
            box-shadow: 0 0 0 2px white, 0 0 0 4px #ff6b6b;
        }
        .status-message {
            margin-top: 20px;
            padding: 10px;
            border-radius: 5px;
            background-color: #f8f9fa;
            display: none;
        }
        .status-message.error {
            background-color: #ffebee;
            color: #c62828;
            display: block;
        }
        .status-message.success {
            background-color: #e8f5e9;
            color: #2e7d32;
            display: block;
        }
        .hidden {
            display: none !important;
        }
        #downloadBtn {
            background-color: #43a047;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ff6b6b;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 2s linear infinite;
            margin: 10px auto;
            display: none;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .makeup-toggle {
            margin: 10px 0;
        }
        .opacity-control {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .opacity-slider {
            flex: 1;
            max-width: 150px;
        }
        .opacity-value {
            min-width: 40px;
            text-align: right;
        }
    </style>
</head>
<body>
    <header>
        <h1>Real-Time Virtual Makeup</h1>
        <p>Try on virtual makeup in real-time!</p>
    </header>

    <div class="container">
        <div class="app-container">
            <div class="webcam-container">
                <div class="video-wrapper">
                    <video id="webcam" autoplay playsinline></video>
                    <canvas id="output_canvas"></canvas>
                </div>
                <div class="camera-controls">
                    <button id="startCameraBtn">Start Camera</button>
                    <button id="downloadBtn" disabled>Take Screenshot</button>
                </div>
                <div class="status-message" id="statusMessage"></div>
                <div class="loader" id="loader"></div>
            </div>

            <div class="controls-container">
                <h2>Makeup Options</h2>
                
                <!-- Eyelid and Eyeliner Toggles -->
                <div class="makeup-toggle">
                    <input type="checkbox" id="eyelinerToggle" checked>
                    <label for="eyelinerToggle">Eyeliner</label>
                    <div class="eyeliner-options" style="margin-left: 20px; margin-top: 5px;">
                        <div>
                            <input type="checkbox" id="upperEyelinerToggle" checked>
                            <label for="upperEyelinerToggle">Upper Eyeliner</label>
                            <div class="opacity-control">
                                <label for="upperEyelinerOpacity">Opacity:</label>
                                <input type="range" id="upperEyelinerOpacity" min="0" max="100" value="50" class="opacity-slider">
                                <span class="opacity-value">50%</span>
                            </div>
                        </div>
                        <div>
                            <input type="checkbox" id="kajalToggle" checked>
                            <label for="kajalToggle">Kajal (Lower Eyeliner)</label>
                            <div class="opacity-control">
                                <label for="kajalOpacity">Opacity:</label>
                                <input type="range" id="kajalOpacity" min="0" max="100" value="37" class="opacity-slider">
                                <span class="opacity-value">37%</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="makeup-toggle">
                    <input type="checkbox" id="cheeksToggle" checked>
                    <label for="cheeksToggle">Cheeks</label>
                    <div class="opacity-control">
                        <label for="cheeksOpacity">Opacity:</label>
                        <input type="range" id="cheeksOpacity" min="0" max="45" value="34" class="opacity-slider">
                        <span class="opacity-value">34%</span>
                    </div>
                </div>

                <!-- Color Palettes -->
                <div class="feature-selector">
                    <h3>Eyeliner Color</h3>
                    <div id="eyelinerColors" class="color-palette">
                        <div class="color-option selected" style="background-color: #000000;" data-color="black"></div>
                        <div class="color-option" style="background-color: #4B0082;" data-color="purple"></div>
                        <div class="color-option" style="background-color: #8B4513;" data-color="brown"></div>
                    </div>

                    <h3>Kajal Color</h3>
                    <div id="kajalColors" class="color-palette">
                        <div class="color-option selected" style="background-color: #000000;" data-color="black"></div>
                        <div class="color-option" style="background-color: #4B0082;" data-color="purple"></div>
                        <div class="color-option" style="background-color: #8B4513;" data-color="brown"></div>
                    </div>

                    <h3>Cheeks Color</h3>
                    <div id="cheeksColors" class="color-palette">
                        <div class="color-option selected" style="background-color: #FF7F7F;" data-color="pink"></div>
                        <div class="color-option" style="background-color: #FFAA7F;" data-color="peach"></div>
                        <div class="color-option" style="background-color: #CD7F32;" data-color="bronze"></div>
                        <div class="color-option" style="background-color: #000000;" data-color="black"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            // DOM Elements
            const video = document.getElementById('webcam');
            const outputCanvas = document.getElementById('output_canvas');
            const startCameraBtn = document.getElementById('startCameraBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const statusMessage = document.getElementById('statusMessage');
            const loader = document.getElementById('loader');
            
            // Canvas context
            const outputCtx = outputCanvas.getContext('2d');
            
            // Makeup state
            let currentColors = {
                eyeliner: 'black',
                kajal: 'black',
                cheeks: 'pink'
            };

            let makeupToggles = {
                eyeliner: true,
                upperEyeliner: true,
                kajal: true,
                cheeks: true
            };

            let makeupOpacity = {
                upperEyeliner: 0.5,  // 50%
                kajal: 0.37,        // 37%
                cheeks: 0.34        // 34%
            };
            
            // Face detection state
            let faceMesh = null;
            let camera = null;
            
            function onResults(results) {
                if (!results.multiFaceLandmarks || !results.image) {
                    return;
                }

                try {
                    outputCanvas.width = video.videoWidth;
                    outputCanvas.height = video.videoHeight;
                    outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
                    outputCtx.drawImage(results.image, 0, 0, outputCanvas.width, outputCanvas.height);

                    if (results.multiFaceLandmarks.length > 0) {
                        const landmarks = results.multiFaceLandmarks[0];
                        
                        // Apply each makeup feature if toggled on
                        if (makeupToggles.eyeliner) {
                            try {
                                applyEyelinerMakeup(landmarks, currentColors.eyeliner, currentColors.kajal);
                            } catch (error) {
                                console.error('Error applying eyeliner/kajal:', error);
                            }
                        }
                        if (makeupToggles.cheeks) {
                            try {
                                applyCheeksMakeup(landmarks, currentColors.cheeks);
                            } catch (error) {
                                console.error('Error applying cheeks:', error);
                            }
                        }
                        
                        downloadBtn.disabled = false;
                    }
                } catch (error) {
                    console.error('Error in onResults:', error);
                }
            }
            
            // Initialize MediaPipe Face Mesh
            async function initializeFaceMesh() {
                try {
                    showStatus('Loading face detection...', 'success');
                    loader.style.display = 'block';

                    faceMesh = new FaceMesh({
                        locateFile: (file) => {
                            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                        }
                    });

                    await faceMesh.initialize();

                    faceMesh.setOptions({
                        maxNumFaces: 1,
                        refineLandmarks: true,
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });

                    faceMesh.onResults(onResults);

                    showStatus('Face detection ready!', 'success');
                    return true;
                } catch (error) {
                    console.error('Error initializing face detection:', error);
                    showStatus('Error initializing face detection. Please try again.', 'error');
                    return false;
                } finally {
                    loader.style.display = 'none';
                }
            }
            
            // Start camera
            startCameraBtn.addEventListener('click', async () => {
                try {
                    showStatus('Starting camera...', 'success');
                    loader.style.display = 'block';

                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user'
                        }
                    });
                    
                    video.srcObject = stream;
                    await video.play();

                    // Set canvas sizes
                    outputCanvas.width = video.videoWidth;
                    outputCanvas.height = video.videoHeight;

                    await initializeFaceMesh();

                    camera = new Camera(video, {
                        onFrame: async () => {
                            if (faceMesh) {
                                await faceMesh.send({ image: video });
                            }
                        },
                        width: 640,
                        height: 480
                    });

                    await camera.start();
                    startCameraBtn.disabled = true;
                    showStatus('Camera ready!', 'success');
                    loader.style.display = 'none';
                    
                } catch (error) {
                    console.error('Error starting camera:', error);
                    showStatus(`Error starting camera: ${error.message}`, 'error');
                    loader.style.display = 'none';
                }
            });
            
            // Setup opacity controls
            document.querySelectorAll('.opacity-slider').forEach(slider => {
                const feature = slider.id.replace('Opacity', '');
                const valueDisplay = slider.nextElementSibling;
                
                slider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    makeupOpacity[feature] = value / 100;
                    valueDisplay.textContent = `${value}%`;
                });
            });
            
            // Apply eyeliner and kajal
            function applyEyelinerMakeup(landmarks, eyelinerColor, kajalColor) {
                if (!landmarks || !makeupToggles.upperEyeliner && !makeupToggles.kajal) return;

                try {
                    const colors = {
                        'black': [0, 0, 0],
                        'purple': [75, 0, 130],
                        'brown': [139, 69, 19]
                    };
                    const selectedEyelinerColor = colors[eyelinerColor] || colors.black;
                    const selectedKajalColor = colors[kajalColor] || colors.black;

                    // Define points specifically for upper eyeliner and lower kajal
                    // Upper eyeliner points (using only upper eyelid points)
                    // Left eye upper lid points (from inner to outer corner)
                    const leftUpperEyeliner = [362, 398, 384, 385, 386, 387, 388, 466];
                    // Right eye upper lid points (from inner to outer corner)
                    const rightUpperEyeliner = [133, 173, 157, 158, 159, 160, 161, 246];
                    
                    // Lower kajal points (using only lower eyelid points)
                    // Left eye lower lid points (from inner to outer corner)
                    const leftKajal = [263, 249, 390, 373, 374, 380, 381, 382];
                    // Right eye lower lid points (from inner to outer corner)
                    const rightKajal = [33, 7, 163, 144, 145, 153, 154, 155];

                    outputCtx.save();

                    function drawUpperEyeliner(points, color) {
                        if (!points || points.length === 0) return;

                        const width = outputCanvas.width * 0.00168;
                        const opacity = makeupOpacity.upperEyeliner;

                        // Create a temporary canvas for better blending
                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCanvas.width = outputCanvas.width;
                        tempCanvas.height = outputCanvas.height;

                        // Draw main line with varying thickness
                        tempCtx.beginPath();
                        let firstPoint = true;

                        // Only use the upper half of the points
                        const halfPoints = points.slice(0, points.length);
                        
                        for (let i = 0; i < halfPoints.length; i++) {
                            const point = landmarks[halfPoints[i]];
                            if (!point) continue;
                            
                            const x = point.x * outputCanvas.width;
                            const y = point.y * outputCanvas.height;
                            
                            // Vary the curve based on position for more natural look
                            const position = i / halfPoints.length;
                            // Adjust curve to be more pronounced in the middle for thicker line
                            const curve = position < 0.3 ? -width * 1.2 : 
                                        position < 0.7 ? -width * 2.4 : 
                                        -width * 1.2;

                            if (firstPoint) {
                                tempCtx.moveTo(x, y + curve);
                                firstPoint = false;
                            } else {
                                const prevPoint = landmarks[halfPoints[i-1]];
                                if (!prevPoint) continue;
                                
                                const prevX = prevPoint.x * outputCanvas.width;
                                const prevY = prevPoint.y * outputCanvas.height;
                                
                                // Adjust control points for smoother curve
                                const cp1x = prevX + (x - prevX) * 0.4;
                                const cp1y = prevY + curve * 0.8;
                                const cp2x = x - (x - prevX) * 0.4;
                                const cp2y = y + curve * 0.8;
                                
                                tempCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y + curve);
                            }
                        }

                        try {
                            const startPoint = landmarks[halfPoints[0]];
                            const endPoint = landmarks[halfPoints[halfPoints.length-1]];
                            if (!startPoint || !endPoint) return;

                            // Create a more complex gradient for realistic look
                            const gradient = tempCtx.createLinearGradient(
                                0, startPoint.y * outputCanvas.height,
                                0, endPoint.y * outputCanvas.height
                            );
                            // Adjust gradient stops for more natural fade with increased opacity
                            gradient.addColorStop(0, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.6})`);
                            gradient.addColorStop(0.3, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.95})`);
                            gradient.addColorStop(0.7, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.95})`);
                            gradient.addColorStop(1, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.6})`);

                            tempCtx.strokeStyle = gradient;
                            tempCtx.lineWidth = width * 3.5; // Increased from 2.5 to 3.5 for thicker line
                            tempCtx.lineCap = 'round';
                            tempCtx.lineJoin = 'round';
                            tempCtx.stroke();

                            // Add a softer inner line with adjusted thickness
                            tempCtx.beginPath();
                            firstPoint = true;

                            for (let i = 0; i < halfPoints.length; i++) {
                                const point = landmarks[halfPoints[i]];
                                if (!point) continue;
                                
                                const x = point.x * outputCanvas.width;
                                const y = point.y * outputCanvas.height;
                                const position = i / halfPoints.length;
                                // Adjust inner curve to be more subtle but proportional to new thickness
                                const innerCurve = position < 0.3 ? -width * 0.6 : 
                                                 position < 0.7 ? -width * 1.0 : 
                                                 -width * 0.6;

                                if (firstPoint) {
                                    tempCtx.moveTo(x, y + innerCurve);
                                    firstPoint = false;
                                } else {
                                    const prevPoint = landmarks[halfPoints[i-1]];
                                    if (!prevPoint) continue;
                                    
                                    const prevX = prevPoint.x * outputCanvas.width;
                                    const prevY = prevPoint.y * outputCanvas.height;
                                    
                                    const cp1x = prevX + (x - prevX) * 0.4;
                                    const cp1y = prevY + innerCurve * 0.8;
                                    const cp2x = x - (x - prevX) * 0.4;
                                    const cp2y = y + innerCurve * 0.8;
                                    
                                    tempCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y + innerCurve);
                                }
                            }

                            const innerGradient = tempCtx.createLinearGradient(
                                0, startPoint.y * outputCanvas.height,
                                0, endPoint.y * outputCanvas.height
                            );
                            // Adjust inner gradient with reduced opacity
                            innerGradient.addColorStop(0, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.3})`);
                            innerGradient.addColorStop(0.5, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.5})`);
                            innerGradient.addColorStop(1, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.3})`);

                            tempCtx.strokeStyle = innerGradient;
                            tempCtx.lineWidth = width * 1.4; // Increased from 1.2 to 1.4 for proportional inner line
                            tempCtx.stroke();

                            // Apply blur for softer look
                            tempCtx.filter = 'blur(0.7px)'; // Slightly increased blur for thicker line
                            tempCtx.globalCompositeOperation = 'source-over';
                            outputCtx.drawImage(tempCanvas, 0, 0);
                            tempCtx.filter = 'none';
                        } catch (error) {
                            console.error('Error drawing upper eyeliner:', error);
                        }
                    }

                    function drawKajal(points, color) {
                        if (!points || points.length === 0) return;

                        const width = outputCanvas.width * 0.0018;
                        const opacity = makeupOpacity.kajal;

                        // Create a temporary canvas for better blending
                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCanvas.width = outputCanvas.width;
                        tempCanvas.height = outputCanvas.height;

                        // Draw main line with varying thickness
                        tempCtx.beginPath();
                        let firstPoint = true;

                        // Only use the lower half of the points
                        const halfPoints = points.slice(0, points.length);
                        
                        for (let i = 0; i < halfPoints.length; i++) {
                            const point = landmarks[halfPoints[i]];
                            if (!point) continue;
                            
                            const x = point.x * outputCanvas.width;
                            const y = point.y * outputCanvas.height;
                            
                            // Vary the curve based on position for more natural look
                            const position = i / halfPoints.length;
                            // Adjust curve to be more pronounced in the middle
                            const curve = position < 0.3 ? width * 1.0 : 
                                        position < 0.7 ? width * 2.0 : 
                                        width * 1.0;

                            if (firstPoint) {
                                tempCtx.moveTo(x, y + curve);
                                firstPoint = false;
                            } else {
                                const prevPoint = landmarks[halfPoints[i-1]];
                                if (!prevPoint) continue;
                                
                                const prevX = prevPoint.x * outputCanvas.width;
                                const prevY = prevPoint.y * outputCanvas.height;
                                
                                // Adjust control points for smoother curve
                                const cp1x = prevX + (x - prevX) * 0.4;
                                const cp1y = prevY + curve * 0.8;
                                const cp2x = x - (x - prevX) * 0.4;
                                const cp2y = y + curve * 0.8;
                                
                                tempCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y + curve);
                            }
                        }

                        try {
                            const startPoint = landmarks[halfPoints[0]];
                            const endPoint = landmarks[halfPoints[halfPoints.length-1]];
                            if (!startPoint || !endPoint) return;

                            // Create a more complex gradient for realistic look
                            const gradient = tempCtx.createLinearGradient(
                                0, startPoint.y * outputCanvas.height,
                                0, endPoint.y * outputCanvas.height
                            );
                            // Adjust gradient stops for more natural fade with reduced opacity
                            gradient.addColorStop(0, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.6})`);
                            gradient.addColorStop(0.3, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.9})`);
                            gradient.addColorStop(0.7, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.9})`);
                            gradient.addColorStop(1, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.6})`);

                            tempCtx.strokeStyle = gradient;
                            tempCtx.lineWidth = width * 3.5; // Slightly thicker for kajal
                            tempCtx.lineCap = 'round';
                            tempCtx.lineJoin = 'round';
                            tempCtx.stroke();

                            // Add a softer inner line
                            tempCtx.beginPath();
                            firstPoint = true;

                            for (let i = 0; i < halfPoints.length; i++) {
                                const point = landmarks[halfPoints[i]];
                                if (!point) continue;
                                
                                const x = point.x * outputCanvas.width;
                                const y = point.y * outputCanvas.height;
                                const position = i / halfPoints.length;
                                // Adjust inner curve to be more subtle
                                const innerCurve = position < 0.3 ? width * 0.5 : 
                                                 position < 0.7 ? width * 0.8 : 
                                                 width * 0.5;

                                if (firstPoint) {
                                    tempCtx.moveTo(x, y + innerCurve);
                                    firstPoint = false;
                                } else {
                                    const prevPoint = landmarks[halfPoints[i-1]];
                                    if (!prevPoint) continue;
                                    
                                    const prevX = prevPoint.x * outputCanvas.width;
                                    const prevY = prevPoint.y * outputCanvas.height;
                                    
                                    const cp1x = prevX + (x - prevX) * 0.4;
                                    const cp1y = prevY + innerCurve * 0.8;
                                    const cp2x = x - (x - prevX) * 0.4;
                                    const cp2y = y + innerCurve * 0.8;
                                    
                                    tempCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y + innerCurve);
                                }
                            }

                            const innerGradient = tempCtx.createLinearGradient(
                                0, startPoint.y * outputCanvas.height,
                                0, endPoint.y * outputCanvas.height
                            );
                            // Adjust inner gradient with reduced opacity
                            innerGradient.addColorStop(0, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.3})`);
                            innerGradient.addColorStop(0.5, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.5})`);
                            innerGradient.addColorStop(1, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${opacity * 0.3})`);

                            tempCtx.strokeStyle = innerGradient;
                            tempCtx.lineWidth = width * 1.6;
                            tempCtx.stroke();

                            // Apply blur for softer look
                            tempCtx.filter = 'blur(1px)'; // Slightly increased blur for kajal
                            tempCtx.globalCompositeOperation = 'source-over';
                            outputCtx.drawImage(tempCanvas, 0, 0);
                            tempCtx.filter = 'none';
                        } catch (error) {
                            console.error('Error drawing kajal:', error);
                        }
                    }

                    // Draw upper eyeliner if enabled
                    if (makeupToggles.upperEyeliner) {
                        drawUpperEyeliner(leftUpperEyeliner, selectedEyelinerColor);
                        drawUpperEyeliner(rightUpperEyeliner, selectedEyelinerColor);
                    }

                    // Draw kajal if enabled
                    if (makeupToggles.kajal) {
                        drawKajal(leftKajal, selectedKajalColor);
                        drawKajal(rightKajal, selectedKajalColor);
                    }

                    outputCtx.restore();
                } catch (error) {
                    console.error('Error in applyEyelinerMakeup:', error);
                }
            }
            
            // Apply blush
            function applyCheeksMakeup(landmarks, color) {
                if (!landmarks) return;

                try {
                    const leftCheekPoints = [117, 118, 119, 123, 147];
                    const rightCheekPoints = [346, 347, 348, 352, 376];
                    
                    function calculateCenter(points) {
                        if (!points || points.length === 0) return null;
                        
                        const center = { x: 0, y: 0 };
                        let validPoints = 0;
                        
                        points.forEach(index => {
                            const point = landmarks[index];
                            if (point) {
                                center.x += point.x;
                                center.y += point.y;
                                validPoints++;
                            }
                        });
                        
                        if (validPoints === 0) return null;
                        
                        center.x /= validPoints;
                        center.y /= validPoints;
                        return center;
                    }
                    
                    const leftCheekCenter = calculateCenter(leftCheekPoints);
                    const rightCheekCenter = calculateCenter(rightCheekPoints);
                    
                    if (!leftCheekCenter || !rightCheekCenter) return;
                    
                    const colors = {
                        'pink': [255, 127, 180],
                        'peach': [255, 186, 169],
                        'bronze': [181, 133, 71],
                        'black': [0, 0, 0]
                    };
                    const selectedColor = colors[color] || colors.pink;
                    
                    // Adjust opacity based on color and user control
                    const baseOpacity = color === 'black' ? 
                        makeupOpacity.cheeks * 0.5 : // Reduce opacity for black color
                        makeupOpacity.cheeks;        // Use full opacity for other colors
                    
                    outputCtx.save();
                    
                    // Adjust oval dimensions for more natural cheek shape
                    const radiusX = outputCanvas.width * 0.045;  // Increased width for more oval shape
                    const radiusY = outputCanvas.width * 0.065;  // Increased height for more oval shape
                    
                    ['left', 'right'].forEach(side => {
                        const center = side === 'left' ? leftCheekCenter : rightCheekCenter;
                        const x = center.x * outputCanvas.width;
                        const y = (center.y * outputCanvas.height) - (outputCanvas.height * 0.015);
                        
                        try {
                            // Create a temporary canvas for better blending
                            const tempCanvas = document.createElement('canvas');
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCanvas.width = outputCanvas.width;
                            tempCanvas.height = outputCanvas.height;
                            
                            // Create a more complex radial gradient for realistic blush
                            const gradient = tempCtx.createRadialGradient(
                                x, y, radiusX * 0.15,  // Reduced inner circle for softer center
                                x, y, radiusX * 1.2   // Increased outer circle for better edge fade
                            );
                            
                            // More natural color stops for blush with softer edges
                            gradient.addColorStop(0, `rgba(${selectedColor[0]}, ${selectedColor[1]}, ${selectedColor[2]}, ${baseOpacity})`);
                            gradient.addColorStop(0.2, `rgba(${selectedColor[0]}, ${selectedColor[1]}, ${selectedColor[2]}, ${baseOpacity * 0.9})`);
                            gradient.addColorStop(0.4, `rgba(${selectedColor[0]}, ${selectedColor[1]}, ${selectedColor[2]}, ${baseOpacity * 0.7})`);
                            gradient.addColorStop(0.6, `rgba(${selectedColor[0]}, ${selectedColor[1]}, ${selectedColor[2]}, ${baseOpacity * 0.4})`);
                            gradient.addColorStop(0.8, `rgba(${selectedColor[0]}, ${selectedColor[1]}, ${selectedColor[2]}, ${baseOpacity * 0.2})`);
                            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                            
                            tempCtx.fillStyle = gradient;
                            tempCtx.beginPath();
                            
                            // Draw more pronounced oval shape
                            tempCtx.save();
                            tempCtx.translate(x, y);
                            tempCtx.scale(1, radiusY / radiusX); // More pronounced oval shape
                            tempCtx.arc(0, 0, radiusX, 0, Math.PI * 2);
                            tempCtx.restore();
                            
                            tempCtx.fill();

                            // Adjust mask gradient for softer edges
                            const maskGradient = tempCtx.createLinearGradient(
                                x, y - radiusY * 1.3,  // Extended upward
                                x, y + radiusY * 1.1   // Extended downward
                            );
                            maskGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                            maskGradient.addColorStop(0.1, 'rgba(0, 0, 0, 0.1)');
                            maskGradient.addColorStop(0.3, 'rgba(0, 0, 0, 0.3)');
                            maskGradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.4)');
                            maskGradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.3)');
                            maskGradient.addColorStop(0.9, 'rgba(0, 0, 0, 0.1)');
                            maskGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                            // Apply the mask
                            tempCtx.globalCompositeOperation = 'destination-in';
                            tempCtx.fillStyle = maskGradient;
                            tempCtx.fillRect(x - radiusX * 1.5, y - radiusY * 1.5, radiusX * 3, radiusY * 3);
                            tempCtx.globalCompositeOperation = 'source-over';

                            // Apply stronger blur for natural blending
                            tempCtx.filter = color === 'black' ? 
                                'blur(18px 24px)' : // Increased blur for black color
                                'blur(15px 20px)';  // Increased blur for other colors
                            outputCtx.drawImage(tempCanvas, 0, 0);
                            tempCtx.filter = 'none';
                            
                            // Add additional soft blur layer for extra edge softening
                            tempCtx.filter = 'blur(10px)';
                            tempCtx.globalAlpha = 0.4; // Increased opacity for stronger effect
                            outputCtx.drawImage(tempCanvas, 0, 0);
                            tempCtx.filter = 'none';
                            tempCtx.globalAlpha = 1.0;
                            
                        } catch (error) {
                            console.error('Error applying cheek makeup:', error);
                        }
                    });
                    
                    outputCtx.restore();
                } catch (error) {
                    console.error('Error in applyCheeksMakeup:', error);
                }
            }
            
            // Download screenshot
            downloadBtn.addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = `virtual-makeup-${Date.now()}.png`;
                link.href = outputCanvas.toDataURL('image/png');
                link.click();
            });
            
            // Show status message
            function showStatus(message, type) {
                statusMessage.textContent = message;
                statusMessage.className = 'status-message';
                if (type) {
                    statusMessage.classList.add(type);
                }
                
                if (type === 'success') {
                    setTimeout(() => {
                        statusMessage.classList.remove('success');
                    }, 5000);
                }
            }
            
            // Setup makeup toggles
            document.querySelectorAll('input[type="checkbox"]').forEach(toggle => {
                toggle.addEventListener('change', (e) => {
                    const feature = e.target.id.replace('Toggle', '');
                    if (feature === 'eyeliner') {
                        // When main toggle is turned off, turn off both specific toggles
                        if (!e.target.checked) {
                            makeupToggles.upperEyeliner = false;
                            makeupToggles.kajal = false;
                            document.getElementById('upperEyelinerToggle').checked = false;
                            document.getElementById('kajalToggle').checked = false;
                        }
                    } else if (feature === 'upperEyeliner' || feature === 'kajal') {
                        // Update the specific toggle
                        makeupToggles[feature] = e.target.checked;
                        
                        // If both specific toggles are off, turn off the main toggle
                        if (!makeupToggles.upperEyeliner && !makeupToggles.kajal) {
                            makeupToggles.eyeliner = false;
                            document.getElementById('eyelinerToggle').checked = false;
                        } else {
                            // If either specific toggle is on, turn on the main toggle
                            makeupToggles.eyeliner = true;
                            document.getElementById('eyelinerToggle').checked = true;
                        }
                    } else {
                        makeupToggles[feature.toLowerCase()] = e.target.checked;
                    }
                });
            });
            
            // Setup color selection
            document.querySelectorAll('.color-option').forEach(colorOption => {
                colorOption.addEventListener('click', () => {
                    const paletteId = colorOption.parentElement.id;
                    const feature = paletteId.replace('Colors', '');
                    
                    currentColors[feature] = colorOption.dataset.color;
                    
                    document.querySelectorAll(`#${paletteId} .color-option`).forEach(option => {
                        option.classList.remove('selected');
                    });
                    colorOption.classList.add('selected');
                });
            });
        });
    </script>
</body>
</html> 